# **Programmers 땅따먹기**

### [문제] [프로그래머스] level2. 땅따먹기(Java)
문제 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/12913

## **제한 조건**
* 행의 개수 N : 100,000 이하의 자연수
* 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
* 점수 : 100 이하의 자연수

## **입출력 예**

|              land               |answer|
|:-------------------------------:|:---:|
| [[1,2,3,5],[5,6,7,8],[4,3,2,1]] |16|

## 문제 핵심
* 열은 4로 고정되어 있고 행은 매개변수에 따라 달라집니다.
* 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 규칙이 있습니다.
* 각 행을 독립적으로 생각하여 최대 값을 구하는 것이 아닌 전체 경우에 수 중 얻을 수 있는 최대값을 구해야합니다.


## **문제 풀이 + 접근 방법**
* 문제를 처음 접근 할 때 각 행을 독립적으로 생각하여 첫 행부터 최대값을 선택하여 마지막행까지 다 더하는 방식으로 접근하였습니다.
* 하지만 이러한 방법은 시간복잡도에서 통과못할 뿐더러 전체 경우에 수에서 얻을 수 있는 최대값을 구하지 못합니다.
* 새로운 접근방법을 고민하던 도 중 전체 경우의 수를 구할 때 사용하는 방식인 다이나믹 프로그램 기법으로 접근하였습니다.

1. i번째 행에서 열이 선택되었을 때 i-1번째 행 중 선택된 열을 제외한 나머지들 중 최대값을 구해서 더하는 방식으로 코드를 작성하였습니다.
2. for문을 사용하여 2번째 행부터 i-1번째 행 중에서 자신 열을 제외한 나머지들 중에서 최대값을 선택하여 마지막 행까지 누적하였습니다.
3. for문을 모두 반복하면 마지막행에는 누적된 결과값이 나오는데 여기서 최대 값이 최고 점수입니다.

## **내가 작성한 코드**
```java
public class Solution {
    public int solution(int[][] land){

        int answer = 0;
        for (int i = 1; i < land.length; i++){
            land[i][0] = land[i][0] + Math.max(land[i-1][1], Math.max(land[i-1][2], land[i-1][3]));
            land[i][1] = land[i][1] + Math.max(land[i-1][0], Math.max(land[i-1][2], land[i-1][3]));
            land[i][2] = land[i][2] + Math.max(land[i-1][0], Math.max(land[i-1][1], land[i-1][3]));
            land[i][3] = land[i][3] + Math.max(land[i-1][0], Math.max(land[i-1][1], land[i-1][2]));
        }

        for (int i = 0; i < 4; i++){
            answer = Math.max(answer, land[land.length - 1][i]);
        }

        return answer;
    }
}
```